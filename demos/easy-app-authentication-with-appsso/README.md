# Demo: Simplify Application Authentication with AppSSO

This demo illustrates how developers can use AppSSO to easily embed
authentication into their apps from a centralized place.

- [RM/3KPs](#resounding-messages)
- [Setup Instructions: Internal APIs](#internal-api-demo)
- [Things To Point Out](#things-to-point-out)

## Resounding Messages

### Easy Authentication with Minimal Configuration

The AppSSO feature within TAP makes it easy for developers to secure
sensitive code paths with guard rails provided by Security Engineers
or Platform Teams. The days of devs fighting with Okta or Active Directory
are over.

#### Three Key Points

- AppSSO "Auth Servers" bridge TAP to your upstream IdP, like Okta,
  Keycloak or Active Directory.
- Apps can easily register themselves with these auth servers with
  configuration code that resides in their repos.
- Access and refresh tokens generated by upstream IdPs are never exposed to
  downstream applications, reducing secrets sprawl and improving your
  security posture.


## Setting up the demo

### Prerequisites

- `ytt`
- Tanzu CLI with the `apps` plugin installed
- AppSSO installed

> The stack provided in this repository sets all of this up for you.

### Instructions

#### Create the AuthServer

##### Summary

An `AuthServer` is a bridge that connects TAP to an upstream identity provider,
like Okta or LDAP.

It does this by providing an OAuth server (for applications within TAP) while
also being an OAuth client that grabs JWTs and other authentication tokens
on the application's behalf.

##### Instructions

1. Create an insecure `AuthServer`. This `AuthServer` will only grant tokens if
   a user provides the username and password provided to the `ytt` command
   below, which are `admin` and `supersecret` respectively:

   ```sh
   openssl genrsa -out /tmp/key.pem 3072 &&
    openssl rsa -in /tmp/key.pem -pubout -out /tmp/key.pub &&
       ytt -v auth_server_username=admin -v auth_server_password=supersecret \
        -v auth_server_privkey="$(cat /tmp/key.pem)" \
        -v auth_server_pubkey="$(cat /tmp/key.pub)" \
        -f ./demos/easy-app-authentication-with-appsso/conf/authserver.yaml |
        kubectl apply -f -
   ```

   Afterwards, wait for the `AuthServer` to come online:

   ```sh
   kubectl wait --for=condition=Ready authserver insecure-auth-server
   ```

2. Create a `ClusterWorkloadRegistrationClass` that uses Services Toolkit to
   expose a service class that points to the `AuthServer`.

   ```sh
   kubectl apply -f
   ./demos/easy-app-authentication-with-appsso/conf/clusterworkloadregistrationclass.yaml
   ```

   Wait for it to become ready.

   ```sh
   kubectl wait --for=condition=Ready cwrc demo-class-sbx
   ```

3. Verify that the `AuthServer` has a service class associated with it.

    ```sh
    tanzu service class get demo-class-sbx
    ```

    This will dump a ton of information if it was successfully registered.

#### Create a new `AuthServer` client with `ClassClaim`

##### Summary

Now that the `AuthServer` has been provisioned, the next step is to create
a client that uses it. This is done with a Service Class Claim.

[Service
Classes](https://docs.vmware.com/en/VMware-Tanzu-Application-Platform/1.6/tap/getting-started-claim-services.html)
are a TAP feature that enables applications to easily claim access to
Services with minimal configuration. In this case, we're creating a
claim to the `AuthServer` so that we can register our app and get a
OAuth client ID and secret in return.

Service Classes work with [Service Bindings](https://servicebinding.io) to
expose these details as a Secret that the app can automatically use.

##### Instructions

4. Now it's time to set up our authenticated app.

   Create the `ClassClaim` that's in `example-app/config`:

   ```sh
   ytt -v appNS=apps -v className=demo-class-sbx \
    -f ./demos/easy-app-authentication-with-appsso/example-app/config/ssoclassclaim.yaml |
    kubectl apply -f -
   ```

   Then wait for it to become ready.

   ```sh
   kubectl wait --for=condition=Ready -n apps \
    classclaim example-app
   ```

#### Deploy the Example App Backend

##### Summary

The `angular-frontend` Example App that we'll be deploying does not
come with a backend. According to [its
instructions](https://github.com/vmware-tanzu/application-accelerator-samples/blob/main/angular-frontend/README.md#prerequisites),
it needs a backend that can respond to two HTTP endpoints:

- `GET /api/customer-profiles/`
- `POST /api/customer-profiles/ # Content-Type: application/json`

While it recommends using the Java Restful Web App or C# Restful Web App
accelerators to do this, this demo comes with a simple, ready-made, and
Golang-based Workload.

(This is also useful in that you can demonstrate running an app that isn't
Java, Python, or C# on TAP!)

This section walks you through deploying it.

> âœ… You do not need to have Golang experience to deploy this workload.

##### Instructions

5. Deploy the backend for the app generated by the Angular Frontend accelerator:

   ```sh
   tanzu apps workload apply \
    -n apps \
    -f ./demos/easy-app-authentication-with-appsso/backend/conf/workload.yaml \
    --local-path ./demos/easy-app-authentication-with-appsso/backend \
    --yes \
    --tail
   ```

6. Wait for the workload to become ready, then confirm that you can reach it
   from your browser by going to `https://example-app-backend.apps.$DOMAIN`.

#### Deploy the frontend

##### Summary

We're now ready to deploy the frontend.

##### Instructions

5. Generate a repo from the "Angular Frontend" accelerator:

   ```sh
   auth_server_url=$(kubectl get authserver insecure-auth-server \
    -o jsonpath='{.status.issuerURI}')
   ytt -v auth_server_url="$auth_server_url" \
     -v auth_server_label_key=env \
     -v auth_server_label_value=sandbox \
     -v apps_ns=apps \
     -o json \
     -f ./demos/easy-app-authentication-with-appsso/conf/accelerator-options.yaml |
     tanzu accelerator generate angular-frontend \
        --options-file /dev/stdin \
        --server-url https://tap-gui.$DOMAIN
   ```

6. Extract the repo somewhere, like `/tmp/example-app`:

   ```sh
   tar -xf angular-frontend.zip -C /tmp
   ```

   This will extract the repo structure into `/tmp/angular-frontend`.

7. Replace the default `client_id` created by this accelerator with
   the one from your `ClassClaim`:

   ```sh
   client_id=$(kubectl get secret -n apps -o jsonpath='{.data.client-id}' \
       $(kubectl get classclaim -n apps example-app -o \
       jsonpath='{.status.binding.name}') | base64 -d)
   sed -i "s;\"apps_example-app\";\"$client_id\";g" \
    /tmp/angular-frontend/src/assets/auth.conf.json
   ```

8. Deploy the workload. Wait for a `Delivery` to be stamped out.

  ```sh
  tanzu apps workload apply \
    -f /tmp/angular-frontend/config/workload.yml
    --local-path /tmp/angular-frontend
    --namespace apps \
    --param clusterBuilder=default \
    --tail \
    --yes
  ```
## Things To Point Out

### The `AuthServer`

**Audience**: Security Engineers, Platform Engineers

`kubectl describe authservers insecure-auth-server`

The `AuthServer` is a web service that brokers creating JWTs for apps that use
it through `ClientRegistrations` and your upstream identity provider (IdP).

While TAP comes with an insecure test `AuthServer` to experiment with the
feature, it is compatible with any IdP that speaks OAuth2.

You can think of this as an interface for apps that want to secure some
endpoints with a login. As long as they can register themselves, they'll get
instant SSO for free.

`kubectl describe cwrc demo-class-sbx`

This is the Service Class that makes my auth server available for
other apps to use. Here, I can give my auth servers match labels.
This way, developers creating ClassClaims don't have to know the
exact name of `AuthServers` they can use.

### The `ClassClaim`

**Audience**: Developers, Security Engineers

`kubectl describe classclaim example-app -n apps`

`ClassClaims` are how developers create new authentication clients
and secure their protected endpoints.

Notice how easily we can provide the OAuth scopes and redirect
paths we need here.

If I need to add a new secured endpoint, I would
simply add it to this claim in Git, push my changes and, if configured,
wait for them to show up here.

Also notice how I'm using `spec.class` to tell this claim the
`AuthServer` I want to use. It's very similar to requesting a storage class
with a PVC, but for adding auth to your app. Pretty neat.

I can create as many of these as I'd like for my application. This is
great if you have multiple code paths that need different scopes, or
even entirely different `AuthServer`s!

### Creating Workloads with `--local-path`

**Audience**: Developers

We usually recommend configuring `Workload`s so that their
supply chains automatically run on new Git commits.

However, if you're working on a new app like our `example-app` here and
aren't ready to set that trigger up, you can provide
`--local-path <PATH>` to `tanzu apps workload apply` to have TAP
create a Workload from your current working directory.

By doing this, TAP will slurp up your code, create an image for it and proceed
to create a `Workload` like normal.

This can be really useful for testing, if you're not already using
TAP's awesome App Live Update IDE integration.

### `src/assets/auth.conf.json`

**Audience**: Developers, Security Engineers

Point out that the `clientID` provided in this configuration file
is generated by, and only works with, the AuthServer within TAP. Actual
client IDs that are created for use with upstream IdPs are never exposed to
the application.

Also point out that while this app is configuring this client ID in clear text,
apps can also use a Kubernetes Secret that is generated by this process
to further secure it.
