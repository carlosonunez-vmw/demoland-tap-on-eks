# Demo: Organize your APIs with TAP

This demo outlines how TAP makes it easy to build and deploy RAISE-compliant
software through custom Cartographer Supply Chains.

Learn more about the RAISE framework
[here)(https://www.doncio.navy.mil/mobile/ContentView.aspx?ID=15943&TypeID=1).

> Creating custom supply chains is an advanced topic. However, the purpose
> of this demo is to illustrate the power that platform engineers inherit by
> being able to create these objects in a Kubernetes-native way.

- [RM/3KPs](#resounding-messages)
- [Setup Instructions: Internal APIs](#internal-api-demo)
- [Things To Point Out](#things-to-point-out)

## Resounding Messages

- Achieve and maintain a continuous Authority to Operate on every commit.
- Use the Supply Chain to incorporate your ISSMs into your path to production.
- Easily integrate with your team's security tools with `SourceScanner`s.

## Setting up the demo

### Prerequisites

- Harbor registry
- Tanzu CLI with the `apps` plugin installed
- `apis.apps.tanzu.vmware.com` TAP package installed

> The stack provided in this repository sets all of this up for you.

### Instructions

1. Apply resources:

```sh
kubectl apply -f ./demos/usn-raise-made-easy/resources/
```

2. Apply the `ClusterTemplate`s

```sh
kubectl apply -f ./demos/usn-raise-made-easy/templates/
```

3. Apply the `SupplyChain`:

```sh
kubectl apply -f ./demos/usn-raise-made-easy/supply_chain.yaml
```

## Running the demo

### Passing Supply Chain

1. Create a fork `github.com/carlosonunez-vmw/example-java-app` within GitHub,
   then update the Git URL reference in
   `./demos/usn-raise-made-easy/workload.yaml` to the URL of your fork.

2. Apply the workload:

   ```sh
   kubectl apply -f ./demos/usn-raise-made-easy/workload.yaml
   ```

3. Visit the TAP Developer Portal to see the workload progress through
   the `raise-to-url` Supply Chain.

### Failing the Supply Chain with a Leaked Secret

Commit the file below into your fork and push your changes:

```text
--- BEGIN RSA PRIVATE KEY ---
whatever
--- END RSA PRIVATE KEY ---
```

The workload should go through the Supply Chain again in about a minute, and
"Detect Secrets" should fail with an error similar to the below in the logs:

```
ERROR: Secrets scan failed! See results below to see where secrets were found.
{
  "name_of_your_file.txt": [
      {
        "type": "Private Key",
        "filename": "/repo/secret.txt",
        "hashed_secret": "some_hash",
        "is_verified": false,
        "line_number": 1
      }
  ]
}
```

## Things To Point Out

### Clean SBOMs with image scanning for free

The `SBOM` stage retrieves the SBOM of the image that TAP generated for the
example Java app in our workload...with some image scanning thrown in for free.
While this is accomplished with Trivy, you can change the image scanning tool as
needed.

### Custom stages: DAST, Detect Secrets

Both `DAST` and `detect-secrets` are custom `ClusterSourceTemplates` that
leverage the built-in installation of Tekton to dynamically scan the website
generated by our `Workload` and detect secrets within its codebase.

This is an example of how platform administrators can enforce controls at scale
for multitudes of workloads regardless of their tech stacks.

## Troubleshooting

WIP.
